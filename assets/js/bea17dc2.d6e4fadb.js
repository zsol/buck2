"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2624],{28453:(e,t,s)=>{s.d(t,{R:()=>l,x:()=>a});var r=s(96540);const i={},n=r.createContext(i);function l(e){const t=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(n.Provider,{value:t},e.children)}},44590:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"prelude/rules/halide/halide_library","title":"halide_library","description":"halide\\\\_library","source":"@site/../docs/prelude/rules/halide/halide_library.md","sourceDirName":"prelude/rules/halide","slug":"/prelude/rules/halide/halide_library","permalink":"/docs/prelude/rules/halide/halide_library","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"ruleSidebar","previous":{"title":"halide","permalink":"/docs/prelude/rules/halide/"},"next":{"title":"haskell","permalink":"/docs/prelude/rules/haskell/"}}');var i=s(74848),n=s(28453);s(56289);const l={},a="halide_library",o={},d=[{value:"halide_library",id:"halide_library-1",level:2},{value:"Parameters",id:"parameters",level:4},{value:"Details",id:"details",level:4}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"halide_library",children:"halide_library"})}),"\n",(0,i.jsx)(t.h2,{id:"halide_library-1",children:"halide_library"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'def halide_library(\n    *,\n    name: str,\n    default_target_platform: None | str = None,\n    target_compatible_with: list[str] = [],\n    compatible_with: list[str] = [],\n    exec_compatible_with: list[str] = [],\n    visibility: list[str] = [],\n    within_view: list[str] = ["PUBLIC"],\n    metadata: OpaqueMetadata = {},\n    tests: list[str] = [],\n    modifiers: OpaqueMetadata = [],\n    _apple_platforms: dict[str, str] = {},\n    compiler_deps: list[str] = [],\n    compiler_flags: list[str] = [],\n    compiler_invocation_flags: list[str] = [],\n    configs: dict[str, dict[str, str]] = {},\n    contacts: list[str] = [],\n    cxx_runtime_type: None | str = None,\n    default_host_platform: None | str = None,\n    default_platform: None | str = None,\n    defaults: dict[str, str] = {},\n    deps: list[str] = [],\n    deps_query: None | str = None,\n    devirt_enabled: bool = False,\n    executable_name: None | str = None,\n    fat_lto: bool = False,\n    focused_list_target: None | str = None,\n    frameworks: list[str] = [],\n    function_name: None | str = None,\n    header_namespace: None | str = None,\n    headers: list[str] | dict[str, str] = [],\n    headers_as_raw_headers_mode: None | str = None,\n    include_directories: list[str] = [],\n    labels: list[str] = [],\n    lang_compiler_flags: dict[str, list[str]] = {},\n    lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = {},\n    lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = {},\n    lang_preprocessor_flags: dict[str, list[str]] = {},\n    libraries: list[str] = [],\n    licenses: list[str] = [],\n    link_deps_query_whole: bool = False,\n    link_group: None | str = None,\n    link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = None,\n    link_style: None | str = None,\n    linker_extra_outputs: list[str] = [],\n    linker_flags: list[str] = [],\n    platform_compiler_flags: list[(str, list[str])] = [],\n    platform_deps: list[(str, list[str])] = [],\n    platform_headers: list[(str, list[str] | dict[str, str])] = [],\n    platform_linker_flags: list[(str, list[str])] = [],\n    platform_preprocessor_flags: list[(str, list[str])] = [],\n    platform_srcs: list[(str, list[str | (str, list[str])])] = [],\n    post_linker_flags: list[str] = [],\n    post_platform_linker_flags: list[(str, list[str])] = [],\n    precompiled_header: None | str = None,\n    prefer_stripped_objects: bool = False,\n    prefix_header: None | str = None,\n    preprocessor_flags: list[str] = [],\n    raw_headers: list[str] = [],\n    srcs: list[str | (str, list[str])] = [],\n    supported_platforms_regex: None | str = None,\n    thin_lto: bool = False,\n    version_universe: None | str = None,\n    weak_framework_names: list[str] = [],\n) -> None\n'})}),"\n",(0,i.jsxs)(t.p,{children:['A halide_library() rule represents a set of Halide sources, along with the "compiler" code needed to compile them into object format (see ',(0,i.jsx)(t.a,{href:"http://halide-lang.org",children:"the Halide site"})," for information about Halide and about static compilation of Halide pipelines). The object code will be generated for the target architecture."]}),"\n",(0,i.jsx)(t.h4,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"name"}),": name of the target"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"default_target_platform"}),": specifies the default target platform, used when no platforms are specified on the command line"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"target_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"exec_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with an execution platform"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"visibility"}),": a list of visibility patterns restricting what targets can depend on this one"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"within_view"}),": a list of visibility patterns restricting what this target can depend on"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"metadata"}),": a key-value map of metadata associated with this target"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"tests"}),": a list of targets that provide tests for this one"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"modifiers"}),": an array of modifiers associated with this target"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"compiler_deps"}),": The dependencies of the halide compiler itself. Targets that depend on the halide_library rule will not include or link the outputs of these targets."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"compiler_flags"}),": Flags to use when compiling any of the above sources (which require compilation)."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"deps"}),": The dependencies of the generated halide pipeline code. This is useful if, for example, your pipeline calls an external function using Halide::Func::define_extern."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"linker_flags"}),": Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"platform_compiler_flags"}),": Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See ",(0,i.jsx)(t.code,{children:"compiler_flags"})," for more information."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"platform_linker_flags"}),": Platform-specific linker flags. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use ",(0,i.jsx)(t.code,{children:"java.util.regex.Pattern"})," syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule is used in a link operation."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"srcs"}),": The set of halide sources to compile for this rule. The sources will be compiled and linked for the host architecture, and the resulting binary will be run to produce the object code for the Halide pipeline."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"supported_platforms_regex"}),": If present, an un-anchored regex (in java.util.regex.Pattern syntax) that matches all platforms that this library supports. It will not be built for other platforms."]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"details",children:"Details"}),"\n",(0,i.jsx)(t.p,{children:"Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"\nhalide_library(\n  # Your library name.\n  name = 'brighter',\n\n  # Your pipeline + compiler sources.\n  srcs = ['halide/main.cpp'],\n\n  # Any dependencies for your compiler. Note that targets that depend on\n  # this rule WILL NOT include or link the output(s) of these targets.\n  compiler_deps = [\n    # You'll need libHalide to use this rule; in our example, we assume it's\n    # located in the 'third-party/halide' directory.\n    '//third-party/halide:halide'\n  ],\n\n  # Any dependencies for your generated shader. Targets that depend on this\n  # rule will include and/or link the output(s) of these targets.\n  deps = [\n    # ...\n  ],\n)\n\n"})})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);