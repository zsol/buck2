"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3077],{28453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>d});var t=n(96540);const r={},s=t.createContext(r);function l(e){const i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(s.Provider,{value:i},e.children)}},83054:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"prelude/rules/cxx/cxx_precompiled_header","title":"cxx_precompiled_header","description":"cxx\\\\precompiled\\\\header","source":"@site/../docs/prelude/rules/cxx/cxx_precompiled_header.md","sourceDirName":"prelude/rules/cxx","slug":"/prelude/rules/cxx/cxx_precompiled_header","permalink":"/docs/prelude/rules/cxx/cxx_precompiled_header","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"ruleSidebar","previous":{"title":"cxx_library","permalink":"/docs/prelude/rules/cxx/cxx_library"},"next":{"title":"cxx_test","permalink":"/docs/prelude/rules/cxx/cxx_test"}}');var r=n(74848),s=n(28453);n(56289);const l={},d="cxx_precompiled_header",a={},c=[{value:"cxx_precompiled_header",id:"cxx_precompiled_header-1",level:2},{value:"Parameters",id:"parameters",level:4},{value:"Details",id:"details",level:4}];function o(e){const i={code:"code",em:"em",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"cxx_precompiled_header",children:"cxx_precompiled_header"})}),"\n",(0,r.jsx)(i.h2,{id:"cxx_precompiled_header-1",children:"cxx_precompiled_header"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:'def cxx_precompiled_header(\n    *,\n    name: str,\n    default_target_platform: None | str = None,\n    target_compatible_with: list[str] = [],\n    compatible_with: list[str] = [],\n    exec_compatible_with: list[str] = [],\n    visibility: list[str] = [],\n    within_view: list[str] = ["PUBLIC"],\n    metadata: OpaqueMetadata = {},\n    tests: list[str] = [],\n    modifiers: OpaqueMetadata = [],\n    _apple_platforms: dict[str, str] = {},\n    contacts: list[str] = [],\n    default_host_platform: None | str = None,\n    deps: list[str] = [],\n    labels: list[str] = [],\n    licenses: list[str] = [],\n    src: str,\n    version_universe: None | str = None,\n) -> None\n'})}),"\n",(0,r.jsxs)(i.p,{children:["A ",(0,r.jsx)(i.code,{children:"cxx_precompiled_header"})," rule specifies a single header file that can be precompiled and made available for use in other build rules such as a ",(0,r.jsx)(i.code,{children:"cxx_library()"})," or a ",(0,r.jsx)(i.code,{children:"cxx_binary()"}),"."]}),"\n",(0,r.jsx)(i.h4,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"name"}),": name of the target"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"default_target_platform"}),": specifies the default target platform, used when no platforms are specified on the command line"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"target_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"exec_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with an execution platform"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"visibility"}),": a list of visibility patterns restricting what targets can depend on this one"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"within_view"}),": a list of visibility patterns restricting what this target can depend on"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"metadata"}),": a key-value map of metadata associated with this target"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"tests"}),": a list of targets that provide tests for this one"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"modifiers"}),": an array of modifiers associated with this target"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"deps"}),": Dependency rules which export headers used by the header specified in ",(0,r.jsx)(i.code,{children:"src"}),"."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"src"}),": The path to the header file that should be precompiled. Only one header file can be specified. But of course this header could include any number of other headers. The included headers could belong to -- that is, be ",(0,r.jsx)(i.code,{children:"exported_headers"})," from -- another rule, in which case, the rule would have to be added to ",(0,r.jsx)(i.code,{children:"deps"})," as usual."]}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"details",children:"Details"}),"\n",(0,r.jsxs)(i.p,{children:["This header file is precompiled by the preprocessor on behalf of the\nC, C++, Objective-C, or Objective-C++ rule using it, via its ",(0,r.jsx)(i.code,{children:"precompiled_header"})," parameter.\nAfterwards the precompiled header is applied during the rule's own compilation\n(often with an appreciable reduction in build time, the main benefit of PCH)."]}),"\n",(0,r.jsxs)(i.p,{children:['This PCH is built once per combination of build flags which might affect the PCH\'s compatibility.\nFor example, a distinct pre-compilation of the header occurs per combination of flags related to\noptimization, debug, architecture, and so on, used by rules which employ PCH.\nThe flags used during the build of the dependent rule (that is, the "PCH-using rule")\nare in effect while building the PCH itself. Similarly, to the same end, the include paths used\nwhen building the PCH are applied to the dependent rule. For example, ',(0,r.jsx)(i.code,{children:"deps"})," in the\nPCH rule are propagated back to the dependent rule, and the PCH's header search paths\n(e.g. ",(0,r.jsx)(i.code,{children:"-I"})," or ",(0,r.jsx)(i.code,{children:"-isystem"})," options) are prefixed onto the list of\ninclude paths for the dependent rule."]}),"\n",(0,r.jsx)(i.p,{children:"Examples:"}),"\n",(0,r.jsxs)(i.p,{children:["The best way to see how the ",(0,r.jsx)(i.code,{children:"cxx_precompiled_header()"})," rule works is with an\nexample. Let there be a header called ",(0,r.jsx)(i.code,{children:"common.h"})," which has the following:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"\n#pragma once\n\n/* Include common C++ files. */\n#include <string>\n#include <map>\n#include <set>\n#include <type_traits>\n#include <vector>\n\n/* Some frequently-used headers from the Folly project. */\n#include <folly/Conv.h>\n#include <folly/Executor.h>\n#include <folly/io/async/EventBase.h>\n\n"})}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{children:"\ncxx_precompiled_header(\n  name = 'common_pch',\n  src = 'common.h',\n  deps = [\n    # Needed for standard C++ headers:\n    '//external/libcxx:headers',\n    # Needed for the Folly includes:\n    '//folly:folly',\n    '//folly/io/async:async',\n  ],\n)\n\ncxx_binary(\n  name = 'main',\n  srcs = ['main.cpp'],\n  precompiled_header = ':common_pch',\n  deps = [ ... ],\n  compiler_flags = ['-g', '-O2', '-fPIC'],\n)\n\n"})}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.code,{children:"cxx_precompiled_header"}),' rule declares a precompiled header "template"\ncontaining the header file path, and dependencies.\nIn this example we indicate that ',(0,r.jsx)(i.code,{children:"common.h"})," is to be precompiled when used by another build rule."]}),"\n",(0,r.jsxs)(i.p,{children:["Note that, by itself, this ",(0,r.jsx)(i.code,{children:"cxx_precompiled_header"})," rule will not result\nin anything being built. The ",(0,r.jsx)(i.em,{children:"usage"}),' of this rule from another rule --\nan "instantiation" of this precompiled header template -- is what will trigger the\nPCH build.']}),"\n",(0,r.jsxs)(i.p,{children:["In the example above, the build for the binary named ",(0,r.jsx)(i.code,{children:'"main"'})," will depend on\nthe header being precompiled in a separate step, prior to compiling ",(0,r.jsx)(i.code,{children:"main.cpp"}),",\nand the resulting PCH will be used in ",(0,r.jsx)(i.code,{children:"main"}),"'s compilation."]}),"\n",(0,r.jsxs)(i.p,{children:["The dependencies specified in this precompiled header rule's ",(0,r.jsx)(i.code,{children:"deps"})," are transitive; they\nwill propagate to rules using this PCH, so that during link time, any libraries which are\nrequired by the code made available in the header will be included in the final binary build."]}),"\n",(0,r.jsxs)(i.p,{children:['The precompiled header dynamically created from the "template" will be built with flags\nwhich would be used in the dependent rule. In this case, ',(0,r.jsx)(i.code,{children:"main"}),"'s use of specific\ncompiler flags ",(0,r.jsx)(i.code,{children:"-g -O2 -fPIC"})," will result in the production of a precompiled header\nwith the same flags. This is so the precompiled code fully jives with rules using the PCH,\ni.e. they will have the same debug, optimization, CPU, etc. options. (The compiler is usually\nsmart enough to reject a bad PCH, fortunately. But we want to ensure we take the appropriate\nsteps to ensure we ",(0,r.jsx)(i.em,{children:"always have"})," a PCH which works with any build that uses it.)"]}),"\n",(0,r.jsxs)(i.p,{children:["Another effect of a rule using a precompiled header is that the rule's list of\nbuild flags will change; not just to employ PCH with e.g. ",(0,r.jsx)(i.code,{children:"-include-pch"}),' (if using Clang), but also, to alter the sequence of header search paths.\nThe rule using the precompiled header will "inherit" the lists of paths used\nduring the PCH build, applying them ',(0,r.jsx)(i.em,{children:"first"})," in its own search paths.\nThis is to ensure that an ",(0,r.jsx)(i.code,{children:"#include"})," directive will resolve in exactly\nthe same way in this build as it would have in the PCH, to ensure full compatibility\nbetween the PCH and other rule's builds. For example, if the PCH were to use one version\nof ",(0,r.jsx)(i.code,{children:"stdcxx"})," and another rule use a different version, the version differences\nwon't clash, thereby avoiding different versions of the ",(0,r.jsx)(i.code,{children:"<cstring>"})," header\nused between the precompiled header and the dependent rule, and preventing confused\nstructure definitions, ABI incompatibility, and so on (catastrophe, in other words)."]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);