"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6178],{28453:(e,s,r)=>{r.d(s,{R:()=>l,x:()=>a});var n=r(96540);const i={},t=n.createContext(i);function l(e){const s=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),n.createElement(t.Provider,{value:s},e.children)}},88017:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"prelude/rules/cxx/cxx_library","title":"cxx_library","description":"cxx\\\\_library","source":"@site/../docs/prelude/rules/cxx/cxx_library.md","sourceDirName":"prelude/rules/cxx","slug":"/prelude/rules/cxx/cxx_library","permalink":"/docs/prelude/rules/cxx/cxx_library","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"ruleSidebar","previous":{"title":"cxx_genrule","permalink":"/docs/prelude/rules/cxx/cxx_genrule"},"next":{"title":"cxx_precompiled_header","permalink":"/docs/prelude/rules/cxx/cxx_precompiled_header"}}');var i=r(74848),t=r(28453);r(56289);const l={},a="cxx_library",o={},d=[{value:"cxx_library",id:"cxx_library-1",level:2},{value:"Parameters",id:"parameters",level:4},{value:"Details",id:"details",level:4},{value:"Building requires a specified top-level target",id:"building-requires-a-specified-top-level-target",level:4},{value:"Dependencies of the cxx_library also require a top-level target",id:"dependencies-of-the-cxx_library-also-require-a-top-level-target",level:4}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"cxx_library",children:"cxx_library"})}),"\n",(0,i.jsx)(s.h2,{id:"cxx_library-1",children:"cxx_library"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:'def cxx_library(\n    *,\n    name: str,\n    default_target_platform: None | str = None,\n    target_compatible_with: list[str] = [],\n    compatible_with: list[str] = [],\n    exec_compatible_with: list[str] = [],\n    visibility: list[str] = [],\n    within_view: list[str] = ["PUBLIC"],\n    metadata: OpaqueMetadata = {},\n    tests: list[str] = [],\n    modifiers: OpaqueMetadata = [],\n    _apple_platforms: dict[str, str] = {},\n    _create_third_party_build_root: str = "prelude//third-party/tools:create_build",\n    _cxx_hacks: str = "prelude//cxx/tools:cxx_hacks",\n    _cxx_toolchain: str = "gh_facebook_buck2_shims_meta//:cxx",\n    _is_building_android_binary: bool = select({"prelude//os:building_android_binary": True, "DEFAULT": False}),\n    _meta_apple_library_validation_enabled: bool = False,\n    allow_cache_upload: None | bool = None,\n    archive_allow_cache_upload: bool = False,\n    auto_link_groups: bool = False,\n    bridging_header: None | str = None,\n    can_be_asset: None | bool = None,\n    compiler_flags: list[str] = [],\n    contacts: list[str] = [],\n    coverage_instrumentation_compiler_flags: list[str] = [],\n    cuda_compile_style: str = "mono",\n    cxx_runtime_type: None | str = None,\n    default_host_platform: None | str = None,\n    default_platform: None | str = None,\n    defaults: dict[str, str] = {},\n    deffile: None | str = None,\n    deps: list[str] = [],\n    deps_query: None | str = None,\n    devirt_enabled: bool = False,\n    diagnostics: dict[str, str] = {},\n    executable_name: None | str = None,\n    export_header_unit: None | str = None,\n    export_header_unit_filter: list[str] = [],\n    exported_deps: list[str] = [],\n    exported_header_style: str = "local",\n    exported_headers: list[str] | dict[str, str] = [],\n    exported_lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = {},\n    exported_lang_preprocessor_flags: dict[str, list[str]] = {},\n    exported_linker_flags: list[str] = [],\n    exported_needs_coverage_instrumentation: bool = False,\n    exported_platform_deps: list[(str, list[str])] = [],\n    exported_platform_headers: list[(str, list[str] | dict[str, str])] = [],\n    exported_platform_linker_flags: list[(str, list[str])] = [],\n    exported_platform_preprocessor_flags: list[(str, list[str])] = [],\n    exported_post_linker_flags: list[str] = [],\n    exported_post_platform_linker_flags: list[(str, list[str])] = [],\n    exported_preprocessor_flags: list[str] = [],\n    extra_xcode_files: list[str] = [],\n    extra_xcode_sources: list[str] = [],\n    fat_lto: bool = False,\n    focused_list_target: None | str = None,\n    force_static: None | bool = None,\n    frameworks: list[str] = [],\n    header_mode: None | str = None,\n    header_namespace: None | str = None,\n    headers: list[str] | dict[str, str] = [],\n    headers_as_raw_headers_mode: None | str = None,\n    include_directories: list[str] = [],\n    include_in_android_merge_map_output: bool = True,\n    labels: list[str] = [],\n    lang_compiler_flags: dict[str, list[str]] = {},\n    lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = {},\n    lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = {},\n    lang_preprocessor_flags: dict[str, list[str]] = {},\n    libraries: list[str] = [],\n    licenses: list[str] = [],\n    link_deps_query_whole: bool = False,\n    link_execution_preference: None | str = None,\n    link_group: None | str = None,\n    link_group_map: None | str | list[(str, list[(None | str | list[None | str], str, None | str | list[str], None | str)], None | dict[str, typing.Any])] = None,\n    link_ordering: None | str = None,\n    link_style: None | str = None,\n    link_whole: None | bool = None,\n    linker_extra_outputs: list[str] = [],\n    linker_flags: list[str] = [],\n    local_linker_flags: list[str] = [],\n    module_name: None | str = None,\n    platform_compiler_flags: list[(str, list[str])] = [],\n    platform_deps: list[(str, list[str])] = [],\n    platform_headers: list[(str, list[str] | dict[str, str])] = [],\n    platform_linker_flags: list[(str, list[str])] = [],\n    platform_preprocessor_flags: list[(str, list[str])] = [],\n    platform_srcs: list[(str, list[str | (str, list[str])])] = [],\n    post_linker_flags: list[str] = [],\n    post_platform_linker_flags: list[(str, list[str])] = [],\n    precompiled_header: None | str = None,\n    prefer_stripped_objects: bool = False,\n    preferred_linkage: str = "any",\n    prefix_header: None | str = None,\n    preprocessor_flags: list[str] = [],\n    public_include_directories: list[str] = [],\n    public_system_include_directories: list[str] = [],\n    raw_headers: list[str] = [],\n    raw_headers_as_headers_mode: None | str = None,\n    reexport_all_header_dependencies: None | bool = None,\n    resources: list[str] | dict[str, str] = [],\n    sdk_modules: list[str] = [],\n    separate_debug_info: bool = False,\n    soname: None | str = None,\n    srcs: list[str | (str, list[str])] = [],\n    static_library_basename: None | str = None,\n    stub: bool = False,\n    supported_platforms_regex: None | str = None,\n    supports_header_symlink_subtarget: bool = False,\n    supports_merged_linking: None | bool = None,\n    supports_python_dlopen: None | bool = None,\n    supports_shlib_interfaces: bool = True,\n    thin_lto: bool = False,\n    use_archive: None | bool = None,\n    use_header_units: bool = False,\n    used_by_wrap_script: bool = False,\n    uses_cxx_explicit_modules: bool = False,\n    uses_explicit_modules: bool = False,\n    version: None | str = None,\n    version_universe: None | str = None,\n    weak_framework_names: list[str] = [],\n) -> None\n'})}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.code,{children:"cxx_library()"})," rule specifies a set of C/C++ source files and also provides flags that specify how those files should be built."]}),"\n",(0,i.jsx)(s.h4,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"name"}),": name of the target"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"default_target_platform"}),": specifies the default target platform, used when no platforms are specified on the command line"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"target_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exec_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with an execution platform"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"visibility"}),": a list of visibility patterns restricting what targets can depend on this one"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"within_view"}),": a list of visibility patterns restricting what this target can depend on"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"metadata"}),": a key-value map of metadata associated with this target"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"tests"}),": a list of targets that provide tests for this one"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"modifiers"}),": an array of modifiers associated with this target"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"allow_cache_upload"}),": Whether to allow uploading the output of this rule to be uploaded to cache when the action is executed locally if the configuration allows (i.e. there is a cache configured and the client has permission to write to it)."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"compiler_flags"}),": Flags to use when compiling any of the above sources (which require compilation)."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"deffile"}),": Specifies the *.def file used on windows to modify a dll's exports in place of explicit ",(0,i.jsx)(s.code,{children:"__declspec(dllexport)"})," declarations. The default is to not use a defile."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"export_header_unit"}),": If not None, export a C++20 header unit visible to dependants (including recursively) with use_header_units set to True."]}),"\n",(0,i.jsx)(s.p,{children:'"include": replace includes of each file in exported_headers or\nraw_headers with an import of the precompiled header unit; files\nthat do not include any of those headers do not load the header\nunit.'}),"\n",(0,i.jsx)(s.p,{children:'"preload": automatically load the precompiled header unit in any\ndependant that uses header units.'}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"export_header_unit_filter"}),": A list of regexes. Each regex should match a set of headers in exported_headers or raw_headers to be precompiled together into one C++20 header unit."]}),"\n",(0,i.jsx)(s.p,{children:'When used with export_header_unit="include", this allows different\nsubsets of headers to be loaded only by files that use them. Each group\nshould only depend on headers in previous groups.'}),"\n",(0,i.jsx)(s.p,{children:'If a header is not matched by any group, it is not precompiled and will\nbe included textually. If no filter is specified, the rule excludes\ninline headers based on a name heuristics (e.g. "-inl.h").'}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_deps"}),": Dependencies that will also appear to belong to any rules that depend on this one. This has two effects: * Exported dependencies will also be included in the link line of dependents of this rules, but normal dependencies will not. * When ",(0,i.jsx)(s.code,{children:"reexport_all_header_dependencies = False"}),", only exported headers of the rules specified here are re-exported."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_header_style"}),": How dependents should include exported headers from this rule. Can be either ",(0,i.jsx)(s.code,{children:"local"})," (e.g. ",(0,i.jsx)(s.code,{children:"-I"}),") or ",(0,i.jsx)(s.code,{children:"system"})," (e.g. ",(0,i.jsx)(s.code,{children:"-isystem"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_headers"}),": The set of header files that are made available for inclusion to the source files in the target and all targets that transitively depend on it. These should be specified as either a list of header files or a dictionary of header names to header files. The headers can be included with ",(0,i.jsx)(s.code,{children:'#include "$HEADER_NAMESPACE/$HEADER_NAME"'})," or ",(0,i.jsx)(s.code,{children:"#include <$HEADER_NAMESPACE/$HEADER_NAME>"}),", where ",(0,i.jsx)(s.code,{children:"$HEADER_NAMESPACE"})," is the value of the target's ",(0,i.jsx)(s.code,{children:"header_namespace"})," attribute, and ",(0,i.jsx)(s.code,{children:"$HEADER_NAME"})," is the header name if specified, and the filename of the header file otherwise. Note that the header name can contain forward slashes (",(0,i.jsx)(s.code,{children:"/"}),"). See ",(0,i.jsx)(s.code,{children:"header_namespace"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_lang_platform_preprocessor_flags"}),": Just as ",(0,i.jsx)(s.code,{children:"lang_platform_preprocessor_flags"}),", but these flags also apply to rules that transitively depend on this rule."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_lang_preprocessor_flags"}),": Just as ",(0,i.jsx)(s.code,{children:"lang_preprocessor_flags"}),", but these flags also apply to rules that transitively depend on this rule."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_linker_flags"}),": Flags to add to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_platform_deps"}),": Platform specific dependencies that will also appear to belong to any rules that depend on this one. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of external dependencies (same format as ",(0,i.jsx)(s.code,{children:"exported_deps"}),") that are exported if the platform matches the regex. See ",(0,i.jsx)(s.code,{children:"exported_deps"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_platform_headers"}),": Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target and all targets that transitively depend on it if the platform matches the regex. See ",(0,i.jsx)(s.code,{children:"headers"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_platform_linker_flags"}),": Platform-specific linker flags for this rule and for all rules that transitively depend on this rule. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use ",(0,i.jsx)(s.code,{children:"java.util.regex.Pattern"})," syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_platform_preprocessor_flags"}),": Platform specific exported preprocessor flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when preprocessing the source files in the target and all targets that transitively depend on it if the platform matches the regex. See ",(0,i.jsx)(s.code,{children:"exported_preprocessor_flags"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_post_linker_flags"}),": Flags to add to the linker command line when the output from this rule, or the output from any rule that transitively depends on this rule, is used in a link operation\u2014with the additional feature that these flags are guaranteed to be placed ",(0,i.jsx)(s.em,{children:"after"})," the compiled object (",(0,i.jsx)(s.code,{children:".o"}),") files on the linker command line."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"exported_post_platform_linker_flags"}),": Platform-specific linker flags for this rule and for all rules that transitively depend on this rule\u2014and that are guaranteed to be placed ",(0,i.jsx)(s.em,{children:"after"})," the compiled object (",(0,i.jsx)(s.code,{children:".o"}),") files on the linker command line. In other respects, the syntax and semantics of this argument are the same as for the ",(0,i.jsx)(s.code,{children:"exported_platform_linker_flags"})," argument."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"extra_xcode_files"}),': When the project is generated, this is the list of files that will added to the project. Those files won\'t be added to the build phase "Compile Sources".']}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"extra_xcode_sources"}),': When the project is generated, this is the list of files that will added to the build phase "Compile Sources" of the given target.']}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"header_namespace"}),": A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (",(0,i.jsx)(s.code,{children:"/"}),"), but cannot start with one. See ",(0,i.jsx)(s.code,{children:"headers"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"headers"}),": The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (",(0,i.jsx)(s.code,{children:"/"}),"). The headers can be included with ",(0,i.jsx)(s.code,{children:'#include "$HEADER_NAMESPACE/$HEADER_NAME"'})," or ",(0,i.jsx)(s.code,{children:"#include <$HEADER_NAMESPACE/$HEADER_NAME>"})," , where ",(0,i.jsx)(s.code,{children:"$HEADER_NAMESPACE"})," is the value of the target's ",(0,i.jsx)(s.code,{children:"header_namespace"}),"  attribute, and ",(0,i.jsx)(s.code,{children:"$HEADER_NAME"})," is the header name if specified, and the filename of the header file otherwise. See ",(0,i.jsx)(s.code,{children:"header_namespace"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"include_directories"}),": A list of include directories (with ",(0,i.jsx)(s.code,{children:"raw_headers"}),") to be added to the compile command for compiling this target (via ",(0,i.jsx)(s.code,{children:"-I"}),"). An include directory is relative to the current package."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"lang_compiler_flags"}),": Language-specific compiler flags. These should be specified as a map of C-family language short names to lists of flags and is used to target flags to sources files for a specific language in the C-family (C, C++, assembler, etc.). The keys in the map can be: * ",(0,i.jsx)(s.code,{children:"cpp-output"})," for C * ",(0,i.jsx)(s.code,{children:"c++-cpp-output"})," for C++ * ",(0,i.jsx)(s.code,{children:"objective-c-cpp-output"})," for Objective-C * ",(0,i.jsx)(s.code,{children:"objective-c++-cpp-output"})," for Objective-C++ * ",(0,i.jsx)(s.code,{children:"cuda-cpp-output"})," for Cuda * ",(0,i.jsx)(s.code,{children:"assembler"})," for Assembly * ",(0,i.jsx)(s.code,{children:"asm"})," for ASM"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"lang_platform_compiler_flags"}),": Language- and platform-specific compiler flags. These should be specified as a map of C-family language short names, as described in ",(0,i.jsx)(s.code,{children:"lang_compiler_flags"}),", to lists of pairs, as described in ",(0,i.jsx)(s.code,{children:"platform_compiler_flags"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"lang_platform_preprocessor_flags"}),": Language- and platform-specific preprocessor flags. These should be specified as a map of C-family language short names, as described in ",(0,i.jsx)(s.code,{children:"lang_preprocessor_flags"}),", to lists of pairs, as described in ",(0,i.jsx)(s.code,{children:"platform_preprocessor_flags"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"lang_preprocessor_flags"}),": Language-specific preprocessor flags. These should be specified as a map of C-family language short names to lists of flags and is used to target flags to sources files for a specific language in the C-family (C, C++, assembler, etc.). The keys in the map can be: * ",(0,i.jsx)(s.code,{children:"c"})," for C * ",(0,i.jsx)(s.code,{children:"c++"})," for C++ * ",(0,i.jsx)(s.code,{children:"objective-c"})," for Objective-C * ",(0,i.jsx)(s.code,{children:"objective-c++"})," for Objective-C++ * ",(0,i.jsx)(s.code,{children:"cuda"})," for Cuda * ",(0,i.jsx)(s.code,{children:"assembler-with-cpp"})," for Assembly * ",(0,i.jsx)(s.code,{children:"asm-with-cpp"})," for ASM"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"link_execution_preference"}),": The execution preference for linking. Options are:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"any : No preference is set, and the link action will be performed based on buck2's executor configuration."}),"\n",(0,i.jsx)(s.li,{children:"full_hybrid : The link action will execute both locally and remotely, regardless of buck2's executor configuration (if\nthe executor is capable of hybrid execution). The use_limited_hybrid setting of the hybrid executor is ignored."}),"\n",(0,i.jsx)(s.li,{children:"local : The link action will execute locally if compatible on current host platform."}),"\n",(0,i.jsx)(s.li,{children:"local_only : The link action will execute locally, and error if the current platform is not compatible."}),"\n",(0,i.jsx)(s.li,{children:"remote : The link action will execute remotely if a compatible remote platform exists, otherwise locally."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"The default is None, expressing that no preference has been set on the target itself."}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"link_style"}),": Determines whether to build and link this rule's dependencies statically or dynamically. Can be either ",(0,i.jsx)(s.code,{children:"static"}),", ",(0,i.jsx)(s.code,{children:"static_pic"})," or ",(0,i.jsx)(s.code,{children:"shared"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"linker_extra_outputs"}),": Declares extra outputs that the linker emits. These identifiers can be used in ",(0,i.jsx)(s.code,{children:"$(output ...)"})," macros in ",(0,i.jsx)(s.code,{children:"linker_flags"})," to interpolate the output path into the linker command line. Useful for custom linkers that emit extra output files."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"linker_flags"}),": Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"local_linker_flags"}),": Flags to add to the linker command line whenever the output from this rule is used in a link operation ",(0,i.jsx)(s.em,{children:"driven by this rule"})," (e.g. when this rule links a shared library, but ",(0,i.jsx)(s.em,{children:"not"})," when the output is linked into a shared library by another rule's link group links)."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"platform_compiler_flags"}),": Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See ",(0,i.jsx)(s.code,{children:"compiler_flags"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"platform_headers"}),": Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target if the platform matches the regex. See ",(0,i.jsx)(s.code,{children:"headers"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"platform_linker_flags"}),": Platform-specific linker flags. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use ",(0,i.jsx)(s.code,{children:"java.util.regex.Pattern"})," syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule is used in a link operation."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"platform_preprocessor_flags"}),": Platform specific preprocessor flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when preprocessing the target's sources. See ",(0,i.jsx)(s.code,{children:"preprocessor_flags"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"platform_srcs"}),": Platform specific source files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of source files or a list of tuples of source files and a list of compilation flags to be preprocessed, compiled and assembled if the platform matches the regex. See ",(0,i.jsx)(s.code,{children:"srcs"})," for more information."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"preferred_linkage"}),": Determines what linkage is used when the library is depended on by another target. To control how the dependencies of this library are linked, use ",(0,i.jsx)(s.code,{children:"link_style"})," instead."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"preprocessor_flags"}),": Flags to use when preprocessing any of the above sources (which require preprocessing)."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"public_include_directories"}),": A list of include directories (with ",(0,i.jsx)(s.code,{children:"raw_headers"}),") to be added to the compile command for compiling this target and every target that depends on it (via ",(0,i.jsx)(s.code,{children:"-I"}),"). An include directory is relative to the current package."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"public_system_include_directories"}),": A list of include directories (with ",(0,i.jsx)(s.code,{children:"raw_headers"}),") to be added to the compile command for compiling this target and every target that depends on it (via ",(0,i.jsx)(s.code,{children:"-isystem"})," if the compiler supports it of via ",(0,i.jsx)(s.code,{children:"-I"})," otherwise). An include directory is relative to the current package."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"raw_headers"}),": The set of header files that can be used for inclusion to the source files in the target and all targets that transitively depend on it. Buck doesn't add raw headers to the search path of a compiler/preprocessor automatically. ",(0,i.jsx)(s.code,{children:"include_directories"})," and ",(0,i.jsx)(s.code,{children:"public_include_directories"})," are the recommended way to add raw headers to the search path (they will be added via ",(0,i.jsx)(s.code,{children:"-I"}),"). ",(0,i.jsx)(s.code,{children:"compiler_flags"}),", ",(0,i.jsx)(s.code,{children:"preprocessor_flags"})," and ",(0,i.jsx)(s.code,{children:"exported_preprocessor_flags"})," can also be used to add such raw headers to the search path if inclusion via ",(0,i.jsx)(s.code,{children:"-isystem"})," or ",(0,i.jsx)(s.code,{children:"-iquote"})," is needed. ",(0,i.jsx)(s.code,{children:"raw_headers"})," cannot be used together with ",(0,i.jsx)(s.code,{children:"headers"})," or ",(0,i.jsx)(s.code,{children:"exported_headers"})," in the same target."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"raw_headers_as_headers_mode"}),": Controls whether raw_headers and *include_directories attributes should be automatically converted to headers and symlink trees and/or header maps via headers. Only has an effect if the cxx_toolchain has explicitly opted into supporting this behavior via a non-default value, even if the value is disabled."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"reexport_all_header_dependencies"}),": Whether to automatically re-export the exported headers of all dependencies."]}),"\n",(0,i.jsxs)(s.p,{children:["When this is set to false, only exported headers from\n",(0,i.jsx)(s.code,{children:"exported_deps"})," are re-exported."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"soname"}),': Sets the soname ("shared object name") of any shared library produced from this rule. The default value is based on the full rule name. The macro ',(0,i.jsx)(s.code,{children:"$(ext)"})," will be replaced with a platform-appropriate extension. An argument can be provided, which is a library version. For example ",(0,i.jsx)(s.code,{children:"soname = 'libfoo.$(ext 2.3)'"})," will be ",(0,i.jsx)(s.code,{children:"libfoo.2.3.dylib"})," on Mac and ",(0,i.jsx)(s.code,{children:"libfoo.so.2.3"})," on Linux."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"srcs"}),": The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the ",(0,i.jsx)(s.a,{href:"https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html",children:"GCC documentation"})," for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. ",(0,i.jsx)(s.code,{children:"''"}),") or a tuple of a string specifying a source file and a list of compilation flags (e.g. ",(0,i.jsx)(s.code,{children:"('', ['-Wall', '-Werror'])"})," ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable)."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"supported_platforms_regex"}),": If present, an un-anchored regex (in java.util.regex.Pattern syntax) that matches all platforms that this library supports. It will not be built for other platforms."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"use_header_units"}),": If True, makes any header unit exported by a dependency (including recursively) through export_header_unit available to the compiler. If false, the compilation ignores header units, regardless of what is exported by dependencies."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"used_by_wrap_script"}),": When using an exopackage Android, if this parameter is set to ",(0,i.jsx)(s.code,{children:"True"}),", then the library is included in the primary APK even if native libraries would otherwise not be placed in it. This is intended for native libraries that are used by a ",(0,i.jsx)(s.a,{href:"https://developer.android.com/ndk/guides/wrap-script",children:"wrap.sh"})," script, which must be placed in the primary APK. Only one of ",(0,i.jsx)(s.code,{children:"can_be_asset"})," and ",(0,i.jsx)(s.code,{children:"used_by_wrap_script"})," can be set for a rule."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"version"}),": A string denoting a meaningful version of this rule that is optionally passed to the linker as extra metadata."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"details",children:"Details"}),"\n",(0,i.jsx)(s.h4,{id:"building-requires-a-specified-top-level-target",children:"Building requires a specified top-level target"}),"\n",(0,i.jsxs)(s.p,{children:["Whether a Buck command builds the ",(0,i.jsx)(s.code,{children:"cxx_library"})," is\ndetermined by the inclusion of a top-level target, such as\na ",(0,i.jsx)(s.code,{children:"cxx_binary()"})," or ",(0,i.jsx)(s.code,{children:"android_binary()"}),", that\ntransitively depends on the ",(0,i.jsx)(s.code,{children:"cxx_library"}),". The set of\ntargets specified to the Buck command (",(0,i.jsx)(s.code,{children:"buck build"}),", ",(0,i.jsx)(s.code,{children:"buck run"}),", etc) must\ninclude one of these top-level targets in order for Buck to build\nthe ",(0,i.jsx)(s.code,{children:"cxx_library"}),". Note that you could specify the top-level target\nimplicitly using a ",(0,i.jsx)(s.code,{children:"build target pattern"})," or you could also specify\nthe top-level target using a buckconfig ",(0,i.jsx)(s.code,{children:"alias"})," defined in ",(0,i.jsx)(s.code,{children:".buckconfig"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"How"})," Buck builds the library also depends on the specified top-level target.\nFor example, a C/C++ binary (",(0,i.jsx)(s.code,{children:"cxx_binary"}),") would require a static non-PIC build of the library,\nwhereas an Android APK (",(0,i.jsx)(s.code,{children:"android_binary"}),") would require a shared PIC-enabled build.\n(PIC stands for position-independent code.)"]}),"\n",(0,i.jsx)(s.h4,{id:"dependencies-of-the-cxx_library-also-require-a-top-level-target",children:"Dependencies of the cxx_library also require a top-level target"}),"\n",(0,i.jsxs)(s.p,{children:["Similarly, in order for Buck to build a target that\nthe ",(0,i.jsx)(s.code,{children:"cxx_library"})," depends on, such as a ",(0,i.jsx)(s.code,{children:"cxx_genrule()"}),",\nyou must specify in the Buck command a top-level target that depends on\nthe ",(0,i.jsx)(s.code,{children:"cxx_library"}),". For example, you could specify\nto ",(0,i.jsx)(s.code,{children:"build"})," a ",(0,i.jsx)(s.code,{children:"cxx_binary"})," that\ndepends on the ",(0,i.jsx)(s.code,{children:"cxx_library"}),". If you specify as\nyour build target the ",(0,i.jsx)(s.code,{children:"cxx_library"})," itself, the build targets\nthat the ",(0,i.jsx)(s.code,{children:"cxx_library"})," depends on ",(0,i.jsx)(s.em,{children:"might not be built"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Examples:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"\n# A rule that includes a single .cpp file and its corresponding header and\n# also supplies an additional flag for compilation.\ncxx_library(\n  name = 'fileutil',\n  srcs = [\n    'fileutil.cpp',\n  ],\n  exported_headers = [\n    'fileutil.h',\n  ],\n  compiler_flags = [\n    '-fno-omit-frame-pointer',\n  ],\n)\n\n# A rule that defines explicit names for its headers\ncxx_library(\n  name = 'mathutils',\n  header_namespace = 'math',\n  srcs = [\n    'trig/src/cos.cpp',\n    'trig/src/tan.cpp',\n  ],\n  exported_headers = {\n    # These are included as <math/trig/cos.h> and <math/trig/tan.h>\n    'trig/cos.h': 'trig/include/cos.h',\n    'trig/tan.h': 'trig/include/tan.h',\n  },\n  compiler_flags = [\n    '-fno-omit-frame-pointer',\n  ],\n)\n\n# A rule that uses different headers and sources per platform\ncxx_library(\n  name = 'vector',\n  # Because of platform_headers, this file can include \"config.h\"\n  # and get the architecture specific header\n  srcs = ['vector.cpp'],\n  platform_srcs = [\n    ('.*armv7$', 'armv7.S'),\n    ('.*x86_64$', 'x86_64.S'),\n  ],\n  exported_headers = [\n    'vector.h',\n  ],\n  platform_headers = [\n    (\n      '.*armv7$',\n      {\n        'config.h': 'config-armv7.h',\n      }\n    ),\n    (\n      '.*x86_64$',\n      {\n        'config.h': 'config-x86_64.h',\n      }\n    ),\n  ],\n)\n\n\n"})})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);