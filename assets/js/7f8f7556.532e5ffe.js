"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[599],{28453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>l});var i=t(96540);const r={},n=i.createContext(r);function a(e){const s=i.useContext(n);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(n.Provider,{value:s},e.children)}},57211:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"prelude/rules/lua/cxx_lua_extension","title":"cxx_lua_extension","description":"cxx\\\\lua\\\\extension","source":"@site/../docs/prelude/rules/lua/cxx_lua_extension.md","sourceDirName":"prelude/rules/lua","slug":"/prelude/rules/lua/cxx_lua_extension","permalink":"/docs/prelude/rules/lua/cxx_lua_extension","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"ruleSidebar","previous":{"title":"lua","permalink":"/docs/prelude/rules/lua/"},"next":{"title":"lua_binary","permalink":"/docs/prelude/rules/lua/lua_binary"}}');var r=t(74848),n=t(28453);t(56289);const a={},l="cxx_lua_extension",o={},c=[{value:"cxx_lua_extension",id:"cxx_lua_extension-1",level:2},{value:"Parameters",id:"parameters",level:4},{value:"Details",id:"details",level:4}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"cxx_lua_extension",children:"cxx_lua_extension"})}),"\n",(0,r.jsx)(s.h2,{id:"cxx_lua_extension-1",children:"cxx_lua_extension"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'def cxx_lua_extension(\n    *,\n    name: str,\n    default_target_platform: None | str = None,\n    target_compatible_with: list[str] = [],\n    compatible_with: list[str] = [],\n    exec_compatible_with: list[str] = [],\n    visibility: list[str] = [],\n    within_view: list[str] = ["PUBLIC"],\n    metadata: OpaqueMetadata = {},\n    tests: list[str] = [],\n    modifiers: OpaqueMetadata = [],\n    _apple_platforms: dict[str, str] = {},\n    base_module: None | str = None,\n    compiler_flags: list[str] = [],\n    contacts: list[str] = [],\n    cxx_runtime_type: None | str = None,\n    default_host_platform: None | str = None,\n    default_platform: None | str = None,\n    defaults: dict[str, str] = {},\n    deps: list[str] = [],\n    executable_name: None | str = None,\n    frameworks: list[str] = [],\n    header_namespace: None | str = None,\n    headers: list[str] | dict[str, str] = [],\n    headers_as_raw_headers_mode: None | str = None,\n    include_directories: list[str] = [],\n    labels: list[str] = [],\n    lang_compiler_flags: dict[str, list[str]] = {},\n    lang_platform_compiler_flags: dict[str, list[(str, list[str])]] = {},\n    lang_platform_preprocessor_flags: dict[str, list[(str, list[str])]] = {},\n    lang_preprocessor_flags: dict[str, list[str]] = {},\n    libraries: list[str] = [],\n    licenses: list[str] = [],\n    linker_extra_outputs: list[str] = [],\n    linker_flags: list[str] = [],\n    platform_compiler_flags: list[(str, list[str])] = [],\n    platform_deps: list[(str, list[str])] = [],\n    platform_headers: list[(str, list[str] | dict[str, str])] = [],\n    platform_linker_flags: list[(str, list[str])] = [],\n    platform_preprocessor_flags: list[(str, list[str])] = [],\n    platform_srcs: list[(str, list[str | (str, list[str])])] = [],\n    post_linker_flags: list[str] = [],\n    post_platform_linker_flags: list[(str, list[str])] = [],\n    precompiled_header: None | str = None,\n    prefix_header: None | str = None,\n    preprocessor_flags: list[str] = [],\n    raw_headers: list[str] = [],\n    srcs: list[str | (str, list[str])] = [],\n    version_universe: None | str = None,\n) -> None\n'})}),"\n",(0,r.jsxs)(s.p,{children:["A cxx_lua_extension() rule is a variant of a C/C++ library which is built as a Lua module. As such, it has a module name formed by the ",(0,r.jsx)(s.code,{children:"base_module"})," parameter and the rule name and implicitly depends on Lua C library (configured via the ",(0,r.jsx)(s.code,{children:".buckconfig"})," parameter."]}),"\n",(0,r.jsx)(s.h4,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"name"}),": name of the target"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"default_target_platform"}),": specifies the default target platform, used when no platforms are specified on the command line"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"target_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with a configuration"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"exec_compatible_with"}),": a list of constraints that are required to be satisfied for this target to be compatible with an execution platform"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"visibility"}),": a list of visibility patterns restricting what targets can depend on this one"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"within_view"}),": a list of visibility patterns restricting what this target can depend on"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"metadata"}),": a key-value map of metadata associated with this target"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"tests"}),": a list of targets that provide tests for this one"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"modifiers"}),": an array of modifiers associated with this target"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"base_module"}),": The package for which the given specified sources and resources should reside in their final location in the top-level binary. If unset, the project relative directory that houses the BUCK file is used."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"compiler_flags"}),": Flags to use when compiling any of the above sources (which require compilation)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"header_namespace"}),": A path prefix when including headers of this target. Defaults to the path from the root of the repository to the directory where this target is defined. Can contain forward slashes (",(0,r.jsx)(s.code,{children:"/"}),"), but cannot start with one. See ",(0,r.jsx)(s.code,{children:"headers"})," for more information."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"headers"}),": The set of header files that are made available for inclusion to the source files in this target. These should be specified as either a list of header files or a dictionary of header names to header files. The header name can contain forward slashes (",(0,r.jsx)(s.code,{children:"/"}),"). The headers can be included with ",(0,r.jsx)(s.code,{children:'#include "$HEADER_NAMESPACE/$HEADER_NAME"'})," or ",(0,r.jsx)(s.code,{children:"#include <$HEADER_NAMESPACE/$HEADER_NAME>"})," , where ",(0,r.jsx)(s.code,{children:"$HEADER_NAMESPACE"})," is the value of the target's ",(0,r.jsx)(s.code,{children:"header_namespace"}),"  attribute, and ",(0,r.jsx)(s.code,{children:"$HEADER_NAME"})," is the header name if specified, and the filename of the header file otherwise. See ",(0,r.jsx)(s.code,{children:"header_namespace"})," for more information."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"linker_flags"}),": Flags to add to the linker command line whenever the output from this rule is used in a link operation, such as linked into an executable or a shared library."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"platform_compiler_flags"}),": Platform specific compiler flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when compiling the target's sources. See ",(0,r.jsx)(s.code,{children:"compiler_flags"})," for more information."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"platform_headers"}),": Platform specific header files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of header files or a dictionary of header names to header files that will be made available for inclusion to the source files in the target if the platform matches the regex. See ",(0,r.jsx)(s.code,{children:"headers"})," for more information."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"platform_linker_flags"}),": Platform-specific linker flags. This argument is specified as a list of pairs where the first element in each pair is an un-anchored regex against which the platform name is matched. The regex should use ",(0,r.jsx)(s.code,{children:"java.util.regex.Pattern"})," syntax. The second element in each pair is a list of linker flags. If the regex matches the platform, these flags are added to the linker command line when the output from this rule is used in a link operation."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"platform_preprocessor_flags"}),": Platform specific preprocessor flags. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is a list of flags to use when preprocessing the target's sources. See ",(0,r.jsx)(s.code,{children:"preprocessor_flags"})," for more information."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"platform_srcs"}),": Platform specific source files. These should be specified as a list of pairs where the first element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform name is matched, and the second element is either a list of source files or a list of tuples of source files and a list of compilation flags to be preprocessed, compiled and assembled if the platform matches the regex. See ",(0,r.jsx)(s.code,{children:"srcs"})," for more information."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"preprocessor_flags"}),": Flags to use when preprocessing any of the above sources (which require preprocessing)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"srcs"}),": The set of C, C++, Objective-C, Objective-C++, or assembly source files to be preprocessed, compiled, and assembled by this rule. We determine which stages to run on each input source based on its file extension. See the ",(0,r.jsx)(s.a,{href:"https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html",children:"GCC documentation"})," for more detail on how file extensions are interpreted. Each element can be either a string specifying a source file (e.g. ",(0,r.jsx)(s.code,{children:"''"}),") or a tuple of a string specifying a source file and a list of compilation flags (e.g. ",(0,r.jsx)(s.code,{children:"('', ['-Wall', '-Werror'])"})," ). In the latter case the specified flags will be used in addition to the rule's other flags when preprocessing and compiling that file (if applicable)."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"details",children:"Details"}),"\n",(0,r.jsx)(s.p,{children:"Examples:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"\n# A rule that builds a Lua extension from a single .cpp file.\ncxx_lua_extension(\n  name = 'mymodule',\n  base_module = 'foo.bar',\n  srcs = [\n    'mymodule.cpp',\n  ],\n  compiler_flags = [\n    '-fno-omit-frame-pointer',\n  ],\n)\n\n# A library rule which has a single source importing the above extension.\nlua_library(\n  name = 'utils',\n  srcs = [\n    'utils.lua',\n  ],\n  deps = [\n    ':mymodule',\n  ],\n)\n\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:'\n-- The `utils.lua` source, wrapped by the `utils` rule above.\n\n-- Import the C/C++ extension build above.\nrequire "foo.bar.mymodule"\n\n...\n\n'})})]})}function h(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);